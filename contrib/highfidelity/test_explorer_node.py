from gevent import monkey; monkey.patch_all()  # noqa: E702

import decimal
import logging
import random
import sys
import time

import gevent
import pytest

from .test_framework.alice_and_bob import alice_and_bob
from .test_framework.authproxy import JSONRPCException
from .test_framework.blockchain.elements import Elements
from .test_framework.kill_elementsd_before_each_function import *  # noqa: E501, F401, F403
from .test_framework.wallet import Wallet, DEFAULT_FEE


logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger('test_explorer_node')


def _wait_for(function):
    for _ in range(10):
        if not function():
            time.sleep(1)
        else:
            return
    raise TimeoutError


def test_slave_sees_all_blocks_and_transactions(blockchain):
    # All nodes on a blockchain see all transactions. Think of these
    # transactions as "proposed" lines in a giant public ledger book.
    with alice_and_bob(blockchain) as (alice, bob):
        with blockchain.node('slave') as slave:
            master = Wallet.master_node

            # Wait for master-slave connection.
            _wait_for(lambda: 1 == master.rpc('getinfo')['connections'])

            # Wait for slave to sync initial blockchain from master.
            last_block = master.rpc('listsinceblock')['lastblock']
            _wait_for(lambda: last_block == slave.rpc('listsinceblock')['lastblock'])  # noqa: E501

            # Ensure neither master nor slave have unconfirmed
            # transactions.
            #
            # N.B. Unconfirmed transactions existing prior to the slave-
            # master connection are not propagated. The test does not
            # make this apparent.
            assert 0 == len(master.rpc('getrawmempool'))
            assert 0 == len(slave.rpc('getrawmempool'))

            # Confirm that slave is aware of unconfirmed transactions.
            alice.transact(alice, bob, 10)
            rawmempool = master.rpc('getrawmempool')
            assert 0 < len(rawmempool)
            _wait_for(lambda: rawmempool == slave.rpc('getrawmempool'))

            # Verify that all transactions are confirmed in new block.
            assert None is master.generate_block()
            assert 0 == len(master.rpc('getrawmempool'))
            _wait_for(lambda: 0 == len(slave.rpc('getrawmempool')))

            # Wait for new block to propagate to slave.
            last_block = master.rpc('listsinceblock')['lastblock']
            _wait_for(lambda: last_block == slave.rpc('listsinceblock')['lastblock'])  # noqa: E501


def test_nodes_obey_the_same_rules(blockchain):
    # All nodes share a common set of rules about which transactions
    # should be approved and as a result what an expected or "validated
    # block" will look like given the current pending list of proposed
    # transactions.
    with alice_and_bob(blockchain) as (alice, bob):
        with blockchain.node('slave') as slave:
            master = Wallet.master_node

            # The master and slave nodes have the same signblockscript,
            # so they can validate blocks on a shared blockchain. Only
            # the master has had importprivkey called, so only the
            # master can sign blocks.
            #
            # Above, we have already demonstrated that blocks generated
            # by master are accepted by the slave. Here we demonstrate
            # that blocks generated by slave are not accepted by master.

            Wallet.master_node = slave  # submit transactions to slave

            # Watch for transactions involving alice and bob. This
            # enables the listunspent rpc on the slave for alice and
            # bob, which is used by Wallet to construct transactions.
            slave.rpc('importaddress', alice.address)
            slave.rpc('importaddress', bob.address)

            # Wait for master-slave connection.
            _wait_for(lambda: 1 == master.rpc('getinfo')['connections'])

            # Wait for slave to sync initial blockchain from master.
            last_block = master.rpc('listsinceblock')['lastblock']
            _wait_for(lambda: last_block == slave.rpc('listsinceblock')['lastblock'])  # noqa: E501

            # Alice submits a transaction to the slave.
            assert 0 == len(slave.rpc('getrawmempool'))
            alice.transact(alice, bob, 10)
            assert 0 < len(slave.rpc('getrawmempool'))

            # The slave, which does not possess the block signing key,
            # cannot generate a block.
            assert 'block-proof-invalid' == slave.generate_block()


def test_nodes_are_validators(blockchain):
    # Node forks if and when a created block violates the common set of
    # rules.
    if blockchain is Elements:
        # The Bitcoin network is existence proof of this. Also, above we
        # demonstrate that an Elements node without the signing key
        # cannot generate blocks.
        pass


@pytest.mark.skip(reason='Outside current requirements')
def test_multiple_signers(blockchain):
    # Support of up to x-of-3 multisig is standard.
    # See: https://github.com/ElementsProject/elements/blob/b979d442711c8c3f84d09c1b804af475616056d9/src/policy/policy.cpp#L46  # noqa: E501
    #
    # Also note: x-of-y is supported but non-standard. Non-standard
    # unconfirmed transactions (y > 3) do not propagate by default.
    raise NotImplementedError


@pytest.mark.xfail
def test_multiple_block_creators(blockchain):
    # TL;DR -- There is nothing to test in this case.
    #
    # Elements does not have native support for multiple block
    # creators.
    #
    #   - There are ways to build this functionality externally to the
    #     elements code base, but it is a non-trivial project.
    #
    #   - Elements claims to have this feature on their roadmap for
    #     June 2018, they previously estimated Q1 2018.
    #
    #   - Elements is considering allowing non-open source licensing
    #     of some of their technology to do this, and are "working
    #     on a proposal for us"
    raise NotImplementedError


def test_second_node_cannot_add_transactions(blockchain):
    with alice_and_bob(blockchain) as (alice, bob):
        with blockchain.node('slave') as slave:
            master = Wallet.master_node
            Wallet.master_node = slave  # submit transactions to slave

            # Watch for transactions involving alice and bob. This
            # enables the listunspent rpc on the slave for alice and
            # bob, which is used by Wallet to construct transactions.
            slave.rpc('importaddress', alice.address)
            slave.rpc('importaddress', bob.address)

            # Wait for master-slave connection.
            _wait_for(lambda: 1 == master.rpc('getinfo')['connections'])

            # Wait for slave to sync initial blockchain from master.
            last_block = master.rpc('listsinceblock')['lastblock']
            _wait_for(lambda: last_block == slave.rpc('listsinceblock')['lastblock'])  # noqa: E501

            # Alice submits to the slave a transaction, which fails to
            # propagate as an unconfirmed transaction to the master.
            assert 0 == len(master.rpc('getrawmempool'))
            assert 0 == len(slave.rpc('getrawmempool'))
            alice.transact(alice, bob, 10)
            rawmempool = slave.rpc('getrawmempool')
            assert 0 < len(rawmempool)
            with pytest.raises(TimeoutError):
                _wait_for(lambda: rawmempool == master.rpc('getrawmempool'))

            # The slave, which does not possess the block signing key,
            # cannot generate a block.
            assert 'block-proof-invalid' == slave.generate_block()


def test_stress(blockchain):
    # IN THEORY
    #
    # The elementd defaults provide for 20 concurrent rpc slots, 4
    # active and 16 queued. We reserve 1 of these slots for the
    # BlockGenerator, which periodically generates blocks, and allocate
    # the rest to Marketplace, which submits transactions as soon as
    # slots come available.
    #
    MAX_MARKETPLACE_CONCURRENCY = 19

    TEST_DURATION = 30

    # Do not slow things down with console logging.
    logging.disable(logging.CRITICAL)

    def _post_mortem(greenlet):
        """Drop to pdb upon exception other than GreenletExit."""
        if greenlet.exc_info[0] != gevent.GreenletExit:
            sys.modules['pdb'].post_mortem(greenlet.exc_info[2])

    def spawn(*args, **kwargs):
        """Spawn a greenlet that drops to pdb upon uncaught exception[*].

        * Not including GreenletExit, which indicates normal termination.

        """
        result = gevent.Greenlet(*args, **kwargs)
        result.link_exception(_post_mortem)
        result.start()
        return result

    def pool_spawn(pool, *args, **kwargs):
        result = gevent.Greenlet(*args, **kwargs)
        result.link_exception(_post_mortem)
        pool.start(result)
        return result

    class Marketplace:
        def __init__(self, alice, bob, block_generator, concurrency):
            self.transactions_n = 0
            self.retries = list()
            self._alice = alice
            self._bob = bob
            self._pool = gevent.pool.Pool(concurrency)
            self._is_stopped = False
            self._block_generator = block_generator

        def start(self):
            self._greenlet = spawn(self._run)

        def stop(self):
            self._is_stopped = True
            self._greenlet.join()
            self._pool.join()

        def _run(self):
            """Generate concurrent, random transactions.

            Note: Concurreny is limited by MAX_MARKETPLACE_CONCURRENCY.

            """
            while not self._is_stopped:
                pool_spawn(self._pool, self._submit_transaction)

        def _submit_transaction(self):
            amount = (
                DEFAULT_FEE * 2 + decimal.Decimal(random.random())
            ).quantize(decimal.Decimal(10)**-3)
            choice = random.random() < .5
            try:
                if choice:
                    alice.transact(alice, bob, amount)
                else:
                    alice.transact(bob, alice, amount)
                self.transactions_n += 1
            except JSONRPCException as e:
                self._block_generator.generate_block()

    class BlockGenerator:
        def __init__(self):
            self._semaphore = gevent.lock.Semaphore(0)
            self._is_generating_block = False
            self._is_stopped = False
            self.blocks_n = 0

        def start(self):
            self._greenlet = spawn(self._run)

        def stop(self):
            self._is_stopped = True
            self.generate_block()
            self._greenlet.join()

        def generate_block(self):
            if not self._is_generating_block and self._semaphore.locked():
                self._semaphore.release()

        def _run(self):
            try:
                while not self._is_stopped:
                    self._semaphore.acquire()
                    self._is_generating_block = True
                    Wallet.master_node.generate_block()
                    self._is_generating_block = False
                    self.blocks_n += 1
            except Exception as e:
                import pdb; pdb.set_trace()  # noqa
                pass

    results = {'solo': [], 'pair': []}

    def _run_test(alice, bob, slave=None, concurrency=None):
        block_generator = BlockGenerator()
        marketplace = Marketplace(alice, bob, block_generator, concurrency)
        block_generator.start()
        marketplace.start()
        time.sleep(10)
        marketplace.stop()
        block_generator.stop()

        if slave:
            # Wait for slave to sync initial blockchain from master.
            logger.info('wainting for nodes to sync...')
            time_start = time.time()
            last_block = Wallet.master_node.rpc('listsinceblock')['lastblock']
            _wait_for(lambda: last_block == slave.rpc('listsinceblock')['lastblock'])  # noqa: E501
            time_finish = time.time()

            elapsed = time_finish - time_start
            print(f'seconds to sync: {(elapsed):.2f}')

        all_transactions = Wallet.master_node.rpc(
            'listreceivedbyaddress',
            0,      # include all transactions, even unconfirmed ones
            False,  # do not display addresses never receiving a payment
            True)   # include watch-only addresses

        confirmed_transactions = Wallet.master_node.rpc(
            'listreceivedbyaddress',
            1,      # include transcations having 1+ confirmations
            False,  # do not display addresses never receiving a payment
            True)   # include watch-only addresses

        actual = {x['address'] for x in all_transactions}
        expected = {alice.address, bob.address}
        if expected != actual:
            import pdb; pdb.set_trace()  # noqa
            pass

        if len(all_transactions[0]['txids']) != \
           len(all_transactions[1]['txids']) != \
           len(confirmed_transactions[0]['txids']) - 1 != \
           len(confirmed_transactions[1]['txids']) - 1 != \
           marketplace.transactions_n:
            import pdb; pdb.set_trace()  # noqa
            pass

        txids_n = len(all_transactions[0]['txids'])
        print(f'total transactions: {txids_n}')
        print(f'total blocks: {block_generator.blocks_n}')
        print(f'transactions per second: {txids_n / TEST_DURATION}')
        print(f'transactions per block: {txids_n / block_generator.blocks_n}')  # noqa: E501

        return txids_n / TEST_DURATION

    for concurrency in range(1, MAX_MARKETPLACE_CONCURRENCY):
        print(f'\nrunning test without slave (concurrency={concurrency})...')
        with alice_and_bob(blockchain, debug=False) as (alice, bob):
            results['solo'].append((
                concurrency,
                _run_test(alice, bob, None, concurrency)))

        print(f'\nrunning test with slave (concurrency={concurrency})...')
        with alice_and_bob(blockchain, debug=False) as (alice, bob):
            with blockchain.node('slave', _debug=False) as slave:
                results['pair'].append((
                    concurrency,
                    _run_test(alice, bob, slave, concurrency)))

    with open('result.csv', 'w') as f:
        f.write('concurrency,txns_sec_solo,txns_sec_pair\n')
        for x in zip(results['solo'], results['pair']):
            f.write(f'{x[0][0]},{x[0][1]},{x[1][1]}')
            f.write('\n')
